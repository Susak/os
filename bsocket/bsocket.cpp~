#include<unistd.h>
#include<stdlib.h>
#include<vector>
#include<sstream>
#include<string>
#include<sys/types.h>
#include<memory.h>
#include<sys/socket.h>
#include<netdb.h>
#include<poll.h>
#include<stdio.h>
#include<iostream>
#include<map>
#include<iterator>
#include<algorithm>
#include<arpa/inet.h>
#include<netinet/in.h>

struct multiheadqueue {
    std::vector<char> buffer;
    std::vector<int> pos;
    std::vector<int> ref;
    int size;
    multiheadqueue() {
        pos.push_back(0);
        size = 0;
    }
    void add(std::string &a) {
        std::copy(a.begin(), a.end(), std::back_inserter(buffer));
        size += a.size();
    }

    void update() {
        int min_i = -1;
        int min = -1;
        for (int i = 0; i < pos.size(); i++) {
            if (min > pos[i]) {
                min = pos[i];
                min_i = i;
            }
        }
        for (int i = 1; i < pos.size(); i++) {
            pos[i] -= min;
        }
        std::vector<char> tmp(buffer.size());
        tmp.insert(tmp.begin(), buffer.begin() + min_i,  buffer.end());
        tmp.swap(buffer);
        size -= min;
    }
};
template<class T>
void check_null(T buf) {
    if (buf == NULL) {
        perror("Allocate error\n");
        exit(2);
    }
}

void check_write(int w) {
    if (w < 0) {
        perror("Write error\n");
        exit(3);
    }
}

void check_read(int r) {
    if (r < 0) {
        perror("Read error\n");
        exit(4);
    } 
}
size_t get_next(std::vector<char>  buf, int pos) {
    int i = pos;
    while ((buf[i] != ' ') && (buf[i] != 0) && (buf[i] != '\n')) {
        i++;
    }
    return i;
}
std::string get_str(int a) {
    std::string res;
    std::ostringstream convert;
    convert << a;
    return convert.str();
}
int pid;
std::pair<std::string, int> parse_sr(std::vector<char> &a) {
    auto it = std::find(a.begin(), a.end(), ' ');
    if (it == a.end()) {
        return std::make_pair("", 0);
    }
    it++;
    int num = atoi(std::string(a.begin(), it).data());
    std::cerr << num << "\n";
    std::vector<char> tmp(a.size());
    std::string res(it, it + num);
    std::pair<std::string, int> result(res, num);
    res.push_back('\0');
    tmp.insert(tmp.begin(), it + num,  a.end());
    a.swap(tmp);
    return result;
}
std::vector<std::string > parse_buffer(std::vector<char> a,
        char delim, int sz) {
    a[sz - 1] = ' ';
    auto it = std::find(a.begin(), a.end(), delim);
    std::vector<std::string > res;
    while (it != a.end()) {
        res.push_back(std::string(a.begin(), it));
        it++;
        a.erase(a.begin(), it);
        it = std::find(a.begin(), a.end(), delim);
    }
    return res;
}
int main (int argc, char ** argv) {
    if ((pid = fork())) {
         return 0;  
    } else {
        setsid();
        int status, sd;
        struct addrinfo hints, *res;
        struct sockaddr_storage sock_stor;
        if (argc != 2) {
            perror("Wrong number of argument");
            return 3;
        }
        char * myport = argv[1];
        const size_t buffersize = 4096;
        char * buffer = (char *)malloc(buffersize);
        check_null(buffer);

        memset(&hints, 0, sizeof(hints));
        hints.ai_family = AF_UNSPEC;    
        hints.ai_socktype = SOCK_STREAM;    
        hints.ai_flags = AI_PASSIVE;  
 
        if ((status = getaddrinfo(NULL, myport, &hints, &res)) != 0) {
            perror("error getaddrfinfo");
            return 1;
        }
        if ((sd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1) {
            perror("error socket");
            return 2;
        }
 
        status = 1;
        if (setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &status, sizeof(int)) == -1) {
            close(sd);
            perror("setsockopt fail");
            return 3;
        }
 
        if (bind(sd, res->ai_addr, res->ai_addrlen) == -1) {
                close(sd);
                perror("bind fail");
                return 4;
        }
       
        if (listen(sd, 5) == -1) {
           close(sd);
           perror("listen fail");
           return 5;
        }

        std::vector<struct pollfd> pollfds(1);
        pollfds[0].fd = sd;
        pollfds[0].events = POLLIN | POLLERR;
        std::vector<std::vector< char > > bufread;
        std::vector<char> tmp;
        bufread.push_back(tmp);
        multiheadqueue mqueue;
        while (1) {
            for (size_t i = 1; i < pollfds.size(); i++) {
                pollfds[i].events = POLLERR | POLLHUP | POLLIN ;
                if (mqueue.pos[i] < mqueue.buffer.size()) {
                    pollfds[i].events |= POLLOUT;
                    pollfds[i].revents = 0;
                }
            }
            int polldata = poll(pollfds.data(), pollfds.size(), -1);

            if (polldata < 0) {
                exit(7);
            }
            if ((pollfds[0].revents & POLLERR) ) {
                exit(7);
            }

            if (pollfds[0].revents & POLLIN) {
                printf("Connected");

                sockaddr_in client;
                client.sin_family = AF_INET;
                socklen_t addr_size = sizeof(sock_stor);
                int cfd = accept(sd, (struct sockaddr *) &client, &addr_size);
                if (cfd == -1) {
                    exit(9);
                }

                
                struct pollfd tmp;
                tmp.fd = cfd;
                tmp.events = POLLIN | POLLOUT | POLLERR | POLLHUP;
                pollfds.push_back(tmp);
                std::vector<char> tm;
                bufread.push_back(tm);
                mqueue.pos.push_back(0);
                printf("Connected to new client\n");
            }
            for (size_t i = 1; i < pollfds.size(); i++) {
                if ((pollfds[i].revents & POLLOUT) && (mqueue.pos[i] < mqueue.buffer.size())) {
                    size_t len = buffersize;
                    if ( ( mqueue.buffer.size() - mqueue.pos[i]) < len) {
                        len = mqueue.buffer.size() - mqueue.pos[i];
                    }
                    int w = write(pollfds[i].fd, mqueue.buffer.data() + mqueue.pos[i] , len);
                    check_write(w);
                    mqueue.pos[i] += w;
                }
            }
            for (size_t i = 1; i < pollfds.size(); i++) {
                if (pollfds[i].revents & POLLIN) {
                    int r = read(pollfds[i].fd, buffer, buffersize);
                    check_read(r);
                    for (int j = 0; j < r; j++) {
                        bufread[i].push_back(buffer[j]);
                    }
                    while (1) {
                        int posn = -1;
                        for (size_t j = 0; j < bufread[i].size(); j++) {
                            if (bufread[i][j] == ' ') {
                                posn = j;
                                break;
                            }
                        }
                        if (posn == -1) {
                            break;
                        }
                        std::string strsize;
                        std::string message;
                        size_t curpos = 0;
                        size_t pos = get_next(bufread[i], curpos);
                        for (size_t j = curpos; j < pos; j++) {
                            strsize.push_back(bufread[i][j]);
                        }
                        curpos = pos + 1;

                        int max_len = bufread[i].size() - posn - 1;
                        int size = stoi(strsize);
                        if (max_len >= size) {
                            for (size_t j = curpos; j < curpos + size; j++) {
                                message.push_back(bufread[i][j]);
                            }
                            curpos += size;
                            mqueue.add(message);
                        } else {
                            break;
                        }
                        
                        std::vector<char> tmp;
                        for(size_t j = curpos ; j < bufread[i].size(); j++) {
                            tmp.push_back(bufread[i][j]);
                        } 
                        bufread[i] = tmp;
                    }
                }
            }
        }
    }
}
